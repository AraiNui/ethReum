---
title: "Examples"
author: "Kate Harris"
date: "April 2016"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Getting the Blockchain Data into R
Load the package using the library:

```{r}
library(ethr)
```

If we want to look at the 7.00am to 7.05 am on last day of March, we can use getTransactionInTimeFrame to get the numbers of those blocks.

```{r,cache=TRUE}
blocks <- getTransactionInTimePeriod("2016-03-31 07:00:00 GMT", "2016-03-31 07:05:00 GMT")
blocks
```

Using getBlockTransactions will return the transaction in those. It also returns the blocks which have no transactions (the code below will remove these blocks).

```{r,chache=TRUE,results='hide',message=FALSE}
transactions <- getBlockTransactions(start_block = blocks[1], end_block = blocks[2]) 
```

```{r,}
transactions <- transactions[complete.cases(transactions), ]
dim(transactions)
names(transactions)
```

Any variables prefixed with "bl" relate to the block header while "tr" relates to the individual transactions. 

If you wish to download a larger section of the blockchain, there are two options. The first option is to download the blocks in parallel.
```{r,message=FALSE,warning=FALSE}
library(foreach)
library(doParallel)

workers <- makeCluster(3)
registerDoParallel(workers)
transactions2 <- getBlockTransactions(start_block = blocks[1], end_block = blocks[2], parallel = TRUE) 
```

Another option, if you are want to access a very large chunk of the blockchain, is to use "bulkBlockDownload.R".
```{r,eval=FALSE}
BulkDownload <- bulkBlockDownload(start_block = blocks[1], end_block = blocks[2], data_dir, chunk_size = 50000, parallel = TRUE, cores = 3) 
```

If only the block header data is required:
```{r,results='hide'}
block_headers <- getBlockHeaders(start_block = blocks[1], end_block = blocks[2])
```
This gives the following information:
```{r}
names(block_headers)
```

# Investigating the Data

To investigate a transaction further the receipt can be found using:
```{r}
SingleTrans <- transactions[1,]$trHash
receipt <- eth_getTransactionReceipt(SingleTrans)
receipt
```
Here the gas used is for that single transaction. This, and other hex values, can be converted using 
```{r}
hexDec(receipt$gasUsed)
```
This will return a 'mpfr' value. Use as.numeric to covert into a more useful value. However larger numbers (such as when dealing with wei values), the as.numeric may reduce precision, though this can be manually set.

There is also a 'decHex' to convert from decimal to hex. This may be needed in for example 'eth_getBalance' which requires the block number in hex format. Please check the documentation for input formats. 


Investigating a block can be done using either the block hash or the block number.

```{r,eval=FALSE}
blockNum  <- transactions[49, ]$blNumber
blockHash <- transactions[49, ]$blHash
eth_getBlockByNumber(decHex(blockNum), full_list = FALSE)
eth_getBlockByHash(blockHash, full_list = FALSE)          

```

# Visualising the data

The function 'nodesPlot' is a preliminary function which allows the user to visualize the nodes and transactions using igraph. The function asks for a threshold, which relates to the number of transactions sent of received by an account (i.e., the in- or -out degree). Any accounts above this threshold are then highlighted on the plot. Also transactions which are greater than 3x the standard deviation of the value of the transactions are highlighted (darker arrows).
(Note: this function works better in Rstudio than on command line. If on command line, un-comment "x11()" on line 82.)

```{r,results='hide'}
nodesPlot(table = transactions, degree_thres = 20, save_plot = TRUE)
```

![](nodesmap.png)
